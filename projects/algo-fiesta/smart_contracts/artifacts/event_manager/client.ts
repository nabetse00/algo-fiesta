/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "claim_asset(account,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "freeze_asset(account,uint64,byte[32])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "un_freeze_asset(account,uint64,byte[32])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "withdraw()void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuYXBwcm92YWxfcHJvZ3JhbToKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9lbnRyeXBvaW50QDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fZW50cnlwb2ludEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTAyCiAgICAvLyBjbGFzcyBFdmVudE1hbmFnZXIoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMgogICAgbWV0aG9kICJzdGFydF9ldmVudChzdHJpbmcsYWNjb3VudCxhc3NldCx1aW50NjQsdWludDY0LHN0cmluZ1tdLGJ5dGVbMzJdW10sdWludDY0W10sdWludDY0W10sdWludDY0W10sdWludDY0W10scGF5KXZvaWQiCiAgICBtZXRob2QgImJ1eV90aWNrZXQoYWNjb3VudCx1aW50NjQsdWludDY0LGJ5dGVbMzJdW10scGF5LGF4ZmVyKXZvaWQiCiAgICBtZXRob2QgImNsYWltX2Fzc2V0KGFjY291bnQsdWludDY0KXZvaWQiCiAgICBtZXRob2QgImZyZWV6ZV9hc3NldChhY2NvdW50LHVpbnQ2NCxieXRlWzMyXSl2b2lkIgogICAgbWV0aG9kICJ1bl9mcmVlemVfYXNzZXQoYWNjb3VudCx1aW50NjQsYnl0ZVszMl0pdm9pZCIKICAgIG1ldGhvZCAid2l0aGRyYXcoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX3N0YXJ0X2V2ZW50X3JvdXRlQDQgbWFpbl9idXlfdGlja2V0X3JvdXRlQDUgbWFpbl9jbGFpbV9hc3NldF9yb3V0ZUA2IG1haW5fZnJlZXplX2Fzc2V0X3JvdXRlQDcgbWFpbl91bl9mcmVlemVfYXNzZXRfcm91dGVAOCBtYWluX3dpdGhkcmF3X3JvdXRlQDkKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5fc3RhcnRfZXZlbnRfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjExMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMDIKICAgIC8vIGNsYXNzIEV2ZW50TWFuYWdlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICB0eG5hcyBBc3NldHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludCAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnQgcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgY2FsbHN1YiBzdGFydF9ldmVudAogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9idXlfdGlja2V0X3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNjkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTAyCiAgICAvLyBjbGFzcyBFdmVudE1hbmFnZXIoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50IDIKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludCBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnQgMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50IGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgYXhmZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE2OQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGJ1eV90aWNrZXQKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fY2xhaW1fYXNzZXRfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI0NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMDIKICAgIC8vIGNsYXNzIEV2ZW50TWFuYWdlcihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI0NgogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGNsYWltX2Fzc2V0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2ZyZWV6ZV9hc3NldF9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjYzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEwMgogICAgLy8gY2xhc3MgRXZlbnRNYW5hZ2VyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjYzCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgZnJlZXplX2Fzc2V0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3VuX2ZyZWV6ZV9hc3NldF9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjc2CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEwMgogICAgLy8gY2xhc3MgRXZlbnRNYW5hZ2VyKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjc2CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIGNhbGxzdWIgdW5fZnJlZXplX2Fzc2V0CiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyOTMKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB3aXRoZHJhdwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMDIKICAgIC8vIGNsYXNzIEV2ZW50TWFuYWdlcihBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci5zdGFydF9ldmVudChuYW1lOiBieXRlcywgb3duZXI6IGJ5dGVzLCB1c2RjX2Fzc2V0OiB1aW50NjQsIGJlZ2luX3RzOiB1aW50NjQsIGVuZF90czogdWludDY0LCB0dF91cmxzOiBieXRlcywgdHRfaGFzaDogYnl0ZXMsIHR0X3ByaWNlczogYnl0ZXMsIHR0X3N1cHBseTogYnl0ZXMsIHR0X21heF9wZXJfdXNlcjogYnl0ZXMsIHR0X3NvbGRfYW1vdW50OiBieXRlcywgcGF5X21icjogdWludDY0KSAtPiB2b2lkOgpzdGFydF9ldmVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjExMy0xMjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIHN0YXJ0X2V2ZW50KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgbmFtZTogU3RyaW5nLAogICAgLy8gICAgIG93bmVyOiBBY2NvdW50LAogICAgLy8gICAgIHVzZGNfYXNzZXQ6IEFzc2V0LAogICAgLy8gICAgIGJlZ2luX3RzOiBVSW50NjQsCiAgICAvLyAgICAgZW5kX3RzOiBVSW50NjQsCiAgICAvLyAgICAgdHRfdXJsczogYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5TdHJpbmddLAogICAgLy8gICAgIHR0X2hhc2g6IGFyYzQuRHluYW1pY0FycmF5W2FyYzQuU3RhdGljQXJyYXlbYXJjNC5CeXRlLCBMWzMyXV1dLAogICAgLy8gICAgIHR0X3ByaWNlczogYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5VSW50NjRdLAogICAgLy8gICAgIHR0X3N1cHBseTogYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5VSW50NjRdLAogICAgLy8gICAgIHR0X21heF9wZXJfdXNlcjogYXJjNC5EeW5hbWljQXJyYXlbYXJjNC5VSW50NjRdLAogICAgLy8gICAgIHR0X3NvbGRfYW1vdW50OiBhcmM0LkR5bmFtaWNBcnJheVthcmM0LlVJbnQ2NF0sCiAgICAvLyAgICAgcGF5X21icjogZ3R4bi5QYXltZW50VHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAxMiAwCiAgICBieXRlICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMjkKICAgIC8vIHNlY3VyaXR5X2NoZWNrcyhVSW50NjQoMikpCiAgICBpbnQgMgogICAgY2FsbHN1YiBzZWN1cml0eV9jaGVja3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzMAogICAgLy8gYXBwX2FkZHIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTMxCiAgICAvLyBhc3NlcnQgcGF5X21ici5yZWNlaXZlciA9PSBhcHBfYWRkciwgV1JPTkdfUEFZTUVOVF9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgcmVjZWl2ZXIgaW4gcGF5bWVudCB0eG4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzMgogICAgLy8gYXNzZXJ0IHBheV9tYnIucmVrZXlfdG8gPT0gR2xvYmFsLnplcm9fYWRkcmVzcywgV1JPTkdfUkVfS0VZX1RPCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJla2V5VG8KICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyByZSBrZXkgdG8sIHNob3VsZCBiZSB6ZXJvIGFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzMwogICAgLy8gcHJlX21iciA9IGFwcF9hZGRyLm1pbl9iYWxhbmNlCiAgICBkdXAKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMzQKICAgIC8vIGFzc2VydCBzZWxmLmV2ZW50X3N0YXR1cyA9PSBVSW50NjQoSU5JVCksIFdST05HX1NUQVRVU19OT1RfSU5JVAogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X3N0YXR1cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfc3RhdHVzIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFN0YXR1cyBtdXN0IGJlIElOSVQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzNQogICAgLy8gYXNzZXJ0IG93bmVyICE9IEdsb2JhbC56ZXJvX2FkZHJlc3MsIFpFUk9fQUREUkVTU19FUlJPUgogICAgZnJhbWVfZGlnIC0xMQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYXNzZXJ0IC8vIFplcm8gQWRkcmVzcyBub3QgYWxsb3dlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTM2CiAgICAvLyBzZWxmLmV2ZW50X293bmVyLnZhbHVlID0gb3duZXIKICAgIGJ5dGUgImV2ZW50X293bmVyIgogICAgZnJhbWVfZGlnIC0xMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzNy0xNDQKICAgIC8vICMgb3B0X2luIHRvIHVzZGNfYXNzZXQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PXVzZGNfYXNzZXQsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PTAsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9YXBwX2FkZHIsCiAgICAvLyAgICAgc2VuZGVyPWFwcF9hZGRyLAogICAgLy8gICAgIGZlZT0wCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE0MAogICAgLy8gYXNzZXRfYW1vdW50PTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIC0xMAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEzNy0xMzgKICAgIC8vICMgb3B0X2luIHRvIHVzZGNfYXNzZXQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludCBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTQzCiAgICAvLyBmZWU9MAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMzctMTQ0CiAgICAvLyAjIG9wdF9pbiB0byB1c2RjX2Fzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD11c2RjX2Fzc2V0LAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPWFwcF9hZGRyLAogICAgLy8gICAgIHNlbmRlcj1hcHBfYWRkciwKICAgIC8vICAgICBmZWU9MAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE0NQogICAgLy8gc2VsZi51c2RjX2Fzc2V0ID0gdXNkY19hc3NldAogICAgYnl0ZSAidXNkY19hc3NldCIKICAgIGZyYW1lX2RpZyAtMTAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNDYKICAgIC8vIGN1cnJlbnRfdHMgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTQ3CiAgICAvLyBhc3NlcnQgYmVnaW5fdHMgPiAoY3VycmVudF90cyArIE1JTl9BSEVBRF9USU1FKSwgV1JPTkdfQkVHSU5fVElNRVNUQU1QCiAgICBpbnQgNDMyMDAKICAgICsKICAgIGZyYW1lX2RpZyAtOQogICAgPAogICAgYXNzZXJ0IC8vIFdyb25nIGJlZ2luIHRpbWVzdGFtcCBzaG91bGQgYmUgYXQgbGVhc3QgNDMyMDBzIGluIHRoZSBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE0OAogICAgLy8gYXNzZXJ0IGVuZF90cyA+IChiZWdpbl90cyArIE1JTl9EVVJBVElPTiksIFdST05HX0VORF9USU1FU1RBTVAKICAgIGZyYW1lX2RpZyAtOQogICAgaW50IDg2NDAwCiAgICArCiAgICBmcmFtZV9kaWcgLTgKICAgIDwKICAgIGFzc2VydCAvLyBXcm9uZyBlbmQgdGltZXN0YW1wIHNob3VsZCBiZSBhdCBsZWFzdCA4NjQwMHMgYWZ0ZXIgYmVnaW4gdGltZXN0YW1wCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNDkKICAgIC8vIHNlbGYuZXZlbnRfYmVnaW4udmFsdWUgPSBiZWdpbl90cwogICAgYnl0ZSAiZXZlbnRfYmVnaW4iCiAgICBmcmFtZV9kaWcgLTkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNTAKICAgIC8vIHNlbGYuZXZlbnRfZW5kLnZhbHVlID0gZW5kX3RzCiAgICBieXRlICJldmVudF9lbmQiCiAgICBmcmFtZV9kaWcgLTgKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNTEKICAgIC8vIGZvciBpIGluIHVyYW5nZSh0dF91cmxzLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgLTcKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDAKCnN0YXJ0X2V2ZW50X2Zvcl9oZWFkZXJAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE1MQogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHR0X3VybHMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGJ6IHN0YXJ0X2V2ZW50X2FmdGVyX2ZvckA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNTMKICAgIC8vIHVybD10dF91cmxzW2ldLAogICAgZnJhbWVfZGlnIC03CiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDAKICAgIGFzc2VydCAvLyBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50IDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwMgogICAgZXh0cmFjdF91aW50MTYKICAgIGludCAyCiAgICArCiAgICBleHRyYWN0MwogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTU0CiAgICAvLyBtZXRhZGF0YV9oYXNoPXR0X2hhc2hbaV0uY29weSgpLAogICAgZnJhbWVfZGlnIC02CiAgICBleHRyYWN0IDIgMAogICAgZGlnIDEKICAgIGludCAzMgogICAgKgogICAgaW50IDMyCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE1NQogICAgLy8gcHJpY2U9dHRfcHJpY2VzW2ldLAogICAgZnJhbWVfZGlnIC01CiAgICBleHRyYWN0IDIgMAogICAgZGlnIDEKICAgIGludCA4CiAgICAqCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludCA4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE1NgogICAgLy8gc3VwcGx5PXR0X3N1cHBseVtpXSwKICAgIGZyYW1lX2RpZyAtNAogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBpbnQgOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNTcKICAgIC8vIG1heF9wZXJfdXNlcj10dF9tYXhfcGVyX3VzZXJbaV0sCiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMQogICAgaW50IDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTU4CiAgICAvLyBzb2xkX2Ftb3VudD10dF9zb2xkX2Ftb3VudFtpXSwKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAyIDAKICAgIHN3YXAKICAgIGludCA4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE1Mi0xNTkKICAgIC8vIHR0ID0gVGlja2V0c1R5cGUoCiAgICAvLyAgICAgdXJsPXR0X3VybHNbaV0sCiAgICAvLyAgICAgbWV0YWRhdGFfaGFzaD10dF9oYXNoW2ldLmNvcHkoKSwKICAgIC8vICAgICBwcmljZT10dF9wcmljZXNbaV0sCiAgICAvLyAgICAgc3VwcGx5PXR0X3N1cHBseVtpXSwKICAgIC8vICAgICBtYXhfcGVyX3VzZXI9dHRfbWF4X3Blcl91c2VyW2ldLAogICAgLy8gICAgIHNvbGRfYW1vdW50PXR0X3NvbGRfYW1vdW50W2ldLAogICAgLy8gKQogICAgYnl0ZSAweDAwNDIKICAgIHVuY292ZXIgNgogICAgY29uY2F0CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNjAKICAgIC8vIHNlbGYuY3JlYXRlX3RpY2tldF90eXBlX2JveChpLCB0dCkKICAgIGRpZyAxCiAgICBzd2FwCiAgICBjYWxsc3ViIGNyZWF0ZV90aWNrZXRfdHlwZV9ib3gKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTUxCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UodHRfdXJscy5sZW5ndGgpOgogICAgaW50IDEKICAgICsKICAgIGZyYW1lX2J1cnkgMwogICAgYiBzdGFydF9ldmVudF9mb3JfaGVhZGVyQDIKCnN0YXJ0X2V2ZW50X2FmdGVyX2ZvckA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTYxCiAgICAvLyBzZWxmLm5hbWUgPSBuYW1lCiAgICBieXRlICJuYW1lIgogICAgZnJhbWVfZGlnIC0xMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE2MgogICAgLy8gc2VsZi5sYXN0X3R5cGVfaW5kZXggKz0gdHRfdXJscy5sZW5ndGgKICAgIGludCAwCiAgICBieXRlICJsYXN0X3R5cGVfaW5kZXgiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGxhc3RfdHlwZV9pbmRleCBleGlzdHMKICAgIGZyYW1lX2RpZyAyCiAgICArCiAgICBieXRlICJsYXN0X3R5cGVfaW5kZXgiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTYzCiAgICAvLyBzZWxmLnVwZGF0ZV90byhVSW50NjQoU1RBUlRFRCkpCiAgICBpbnQgMQogICAgY2FsbHN1YiB1cGRhdGVfdG8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE2NAogICAgLy8gcG9zdF9tYnIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE2NQogICAgLy8gcGF5X2Ftb3VudCA9IHBvc3RfbWJyIC0gcHJlX21icgogICAgZnJhbWVfZGlnIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE2NgogICAgLy8gYXNzZXJ0IHBheV9tYnIuYW1vdW50ID09IHBheV9hbW91bnQsIFdST05HX1BBWU1FTlRfQU1PVU5UCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyBhbW91bnQgcGF5bWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTY3CiAgICAvLyBsb2coQVBQX1NUQVJURUQpCiAgICBieXRlICJbRVZFTlQgTUFOQUdFUl0gU3RhcnRlZCIKICAgIGxvZwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3Quc2VjdXJpdHlfY2hlY2tzKHR4bl9udW1iZXI6IHVpbnQ2NCkgLT4gdm9pZDoKc2VjdXJpdHlfY2hlY2tzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTM4LTU0MgogICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gIyBHbG9iYWwgc3Vicm91dGluZXMgIwogICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBzZWN1cml0eV9jaGVja3ModHhuX251bWJlcjogVUludDY0KSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1NDMKICAgIC8vIGFzc2VydCBHbG9iYWwuZ3JvdXBfc2l6ZSA9PSB0eG5fbnVtYmVyLCBXUk9OR19HUk9VUF9TSVpFCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgZ3JvdXAgc2l6ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTQ0CiAgICAvLyBhc3NlcnQgVHhuLnJla2V5X3RvID09IEdsb2JhbC56ZXJvX2FkZHJlc3MsIFdST05HX1JFX0tFWV9UTwogICAgdHhuIFJla2V5VG8KICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyByZSBrZXkgdG8sIHNob3VsZCBiZSB6ZXJvIGFkZHJlc3MKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci5jcmVhdGVfdGlja2V0X3R5cGVfYm94KGluZGV4OiB1aW50NjQsIHR0OiBieXRlcykgLT4gYnl0ZXM6CmNyZWF0ZV90aWNrZXRfdHlwZV9ib3g6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozNTYtMzU4CiAgICAvLyAjIHRpY2tldCB0eXBlcwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBjcmVhdGVfdGlja2V0X3R5cGVfYm94KHNlbGYsIGluZGV4OiBVSW50NjQsIHR0OiBUaWNrZXRzVHlwZSkgLT4gTm9uZToKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzU5CiAgICAvLyBrZXkgPSBzZWxmLmJveF9rZXlfZnJvbV91aW50NjQoQnl0ZXMoVElDS0VUX1RZUEVTX0JPWF9QUkVGSVgpLCBpbmRleCkKICAgIGJ5dGUgInR0LSIKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBib3hfa2V5X2Zyb21fdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozNjAKICAgIC8vIG9wLkJveC5wdXQoa2V5LCB0dC5ieXRlcykKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3B1dAogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuYm94X2tleV9mcm9tX3VpbnQ2NChwcmVmaXg6IGJ5dGVzLCBpbmRleDogdWludDY0KSAtPiBieXRlczoKYm94X2tleV9mcm9tX3VpbnQ2NDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM0NC0zNDkKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vICMgYm94IHN1YnJvdXRpbmVzICMKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vICMgZ2VuZXJhbAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBib3hfa2V5X2Zyb21fdWludDY0KHNlbGYsIHByZWZpeDogQnl0ZXMsIGluZGV4OiBVSW50NjQpIC0+IEJ5dGVzOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozNTAKICAgIC8vIHJldHVybiBvcC5jb25jYXQocHJlZml4LCBvcC5pdG9iKGluZGV4KSkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci51cGRhdGVfdG8obmV3X3N0YXR1czogdWludDY0KSAtPiB2b2lkOgp1cGRhdGVfdG86CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMjgtMzI5CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHVwZGF0ZV90byhzZWxmLCBuZXdfc3RhdHVzOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMzMAogICAgLy8gb2xkX3N0YXR1cyA9IHNlbGYuZXZlbnRfc3RhdHVzCiAgICBpbnQgMAogICAgYnl0ZSAiZXZlbnRfc3RhdHVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfc3RhdHVzIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzMxCiAgICAvLyBpZiBvbGRfc3RhdHVzICE9IG5ld19zdGF0dXM6CiAgICBmcmFtZV9kaWcgLTEKICAgICE9CiAgICBieiB1cGRhdGVfdG9fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMzIKICAgIC8vIHNlbGYuZXZlbnRfc3RhdHVzID0gbmV3X3N0YXR1cwogICAgYnl0ZSAiZXZlbnRfc3RhdHVzIgogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzMzCiAgICAvLyBsb2coQVBQX1NUQVRVU19VUERBVEUsIG9sZF9zdGF0dXMsICJ0byIsIG5ld19zdGF0dXMsIHNlcD0iICIpCiAgICBmcmFtZV9kaWcgMAogICAgaXRvYgogICAgYnl0ZSAiW0VWRU5UIE1BTkdFUl0gU3RhdHVzIFVwZGF0ZWQgZnJvbSAiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGUgIiAiCiAgICBjb25jYXQKICAgIGJ5dGUgInRvIgogICAgY29uY2F0CiAgICBieXRlICIgIgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgbG9nCgp1cGRhdGVfdG9fYWZ0ZXJfaWZfZWxzZUAyOgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLmJ1eV90aWNrZXQob3duZXI6IGJ5dGVzLCBudW1iZXJfdGlja2V0czogdWludDY0LCB0aWNrZXRfdHlwZV9pbmRleDogdWludDY0LCBzZWF0czogYnl0ZXMsIHBheV9tYnI6IHVpbnQ2NCwgcGF5X2Fzc2V0OiB1aW50NjQpIC0+IHZvaWQ6CmJ1eV90aWNrZXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxNjktMTc4CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBidXlfdGlja2V0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgb3duZXI6IEFjY291bnQsCiAgICAvLyAgICAgbnVtYmVyX3RpY2tldHM6IFVJbnQ2NCwKICAgIC8vICAgICB0aWNrZXRfdHlwZV9pbmRleDogVUludDY0LAogICAgLy8gICAgIHNlYXRzOiBTZWF0c0FycmF5LAogICAgLy8gICAgIHBheV9tYnI6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gICAgIHBheV9hc3NldDogZ3R4bi5Bc3NldFRyYW5zZmVyVHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA2IDAKICAgIGludCAwCiAgICBkdXBuIDIKICAgIGJ5dGUgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE3OS0xODAKICAgIC8vICMgY2hlY2tzCiAgICAvLyBzZWN1cml0eV9jaGVja3MoVUludDY0KDMpKQogICAgaW50IDMKICAgIGNhbGxzdWIgc2VjdXJpdHlfY2hlY2tzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxODEKICAgIC8vIHNlbGYuY2hlY2tfc3RhdHVzX25vdF9lbmRlZCgpCiAgICBjYWxsc3ViIGNoZWNrX3N0YXR1c19ub3RfZW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE4MgogICAgLy8gYXBwX2FkZHIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxODMKICAgIC8vIGFzc2VydCBwYXlfbWJyLnJlY2VpdmVyID09IGFwcF9hZGRyLCBXUk9OR19QQVlNRU5UX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBkaWcgMQogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyByZWNlaXZlciBpbiBwYXltZW50IHR4bgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTg0CiAgICAvLyBhc3NlcnQgcGF5X21ici5yZWtleV90byA9PSBHbG9iYWwuemVyb19hZGRyZXNzLCBXUk9OR19SRV9LRVlfVE8KICAgIGZyYW1lX2RpZyAtMgogICAgZ3R4bnMgUmVrZXlUbwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFdyb25nIHJlIGtleSB0bywgc2hvdWxkIGJlIHplcm8gYWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTg1CiAgICAvLyBwcmVfbWJyID0gYXBwX2FkZHIubWluX2JhbGFuY2UKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxODgKICAgIC8vIEJ5dGVzKFRJQ0tFVF9UWVBFU19CT1hfUFJFRklYKSwgdGlja2V0X3R5cGVfaW5kZXgKICAgIGJ5dGUgInR0LSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE4Ni0xODkKICAgIC8vICMgcmV0cmlldmUgdGlja2V0IHR5cGUKICAgIC8vIHR0X2tleSA9IHNlbGYuYm94X2tleV9mcm9tX3VpbnQ2NCgKICAgIC8vICAgICBCeXRlcyhUSUNLRVRfVFlQRVNfQk9YX1BSRUZJWCksIHRpY2tldF90eXBlX2luZGV4CiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTQKICAgIGNhbGxzdWIgYm94X2tleV9mcm9tX3VpbnQ2NAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxOTAKICAgIC8vIHR0ID0gc2VsZi5yZWFkX3RpY2tldF90eXBlX2JveCh0dF9rZXkpCiAgICBjYWxsc3ViIHJlYWRfdGlja2V0X3R5cGVfYm94CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE5MwogICAgLy8gbnVtYmVyX3RpY2tldHMgPT0gc2VhdHMubGVuZ3RoCiAgICBmcmFtZV9kaWcgLTMKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIC01CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTkxLTE5NAogICAgLy8gIyBsZW5ndGggbWF0Y2gKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbnVtYmVyX3RpY2tldHMgPT0gc2VhdHMubGVuZ3RoCiAgICAvLyApLCAibnVtYmVyIG9mIHRpY2tldHMgbXVzdCBlcXVhbCB0byBzZWF0cyBhcnJheSBsZW5ndGgiCiAgICBhc3NlcnQgLy8gbnVtYmVyIG9mIHRpY2tldHMgbXVzdCBlcXVhbCB0byBzZWF0cyBhcnJheSBsZW5ndGgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjE5NS0xOTYKICAgIC8vICMgbm8gb3ZlciBzdXBwbHkKICAgIC8vIHN1cHBseSA9IHR0LnN1cHBseS5uYXRpdmUKICAgIGR1cAogICAgZXh0cmFjdCA0MiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTk3CiAgICAvLyBzb2xkID0gdHQuc29sZF9hbW91bnQubmF0aXZlCiAgICBleHRyYWN0IDU4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxOTgKICAgIC8vIGFzc2VydCBzb2xkICsgbnVtYmVyX3RpY2tldHMgPD0gc3VwcGx5LCBPVkVSX1NVUFBMWQogICAgZnJhbWVfZGlnIC01CiAgICArCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgPD0KICAgIGFzc2VydCAvLyBDYW5ub3QgYnV5IHRoYXQgYW1vdW50IG9mIHRpY2tldHM6IG92ZXIgc3VwcGx5CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxOTktMjAxCiAgICAvLyAjIGVuc3VyZSBvcHMKICAgIC8vICMgYnVkZ2V0IGFwcHJveCA9PiBbZml4ZWQgY29zdCA2MDBdICsgW3ZhcmlhYmxlIGNvc3QgMjAwXSAqIHRpY2tldHMKICAgIC8vIGJ1ZGdldF9hcHByb3ggPSAoc29sZCArIG51bWJlcl90aWNrZXRzKSAqIDIwMCArIDYwMAogICAgaW50IDIwMAogICAgKgogICAgaW50IDYwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjAyCiAgICAvLyBlbnN1cmVfYnVkZ2V0KGJ1ZGdldF9hcHByb3gsIGZlZV9zb3VyY2U9T3BVcEZlZVNvdXJjZS5Hcm91cENyZWRpdCkKICAgIGludCAwCiAgICBjYWxsc3ViIGVuc3VyZV9idWRnZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIwMy0yMDQKICAgIC8vICMgbm8gb3ZlciBtYXggcGVyIHVzZXIKICAgIC8vIG9iX2tleSA9IHNlbGYuYm94X2tleV9mcm9tX2FkZHJlc3MoQnl0ZXMoT1dORVJfQk9YX1BSRUZJWCksIG93bmVyKQogICAgYnl0ZSAib3QtIgogICAgZnJhbWVfZGlnIC02CiAgICBjYWxsc3ViIGJveF9rZXlfZnJvbV9hZGRyZXNzCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIwNQogICAgLy8gb2JfcmVzID0gc2VsZi5yZWFkX293bmVyX2JveChvYl9rZXkpCiAgICBjYWxsc3ViIHJlYWRfb3duZXJfYm94CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIwNwogICAgLy8gaWYgb2Jfa2V5WzFdID09IEJ5dGVzKGIiMSIpOgogICAgZXh0cmFjdCAxIDEKICAgIGJ5dGUgIjEiCiAgICA9PQogICAgZnJhbWVfZGlnIC01CiAgICBzd2FwCiAgICBieiBidXlfdGlja2V0X2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjA4CiAgICAvLyBjb3VudCArPSBvYl9yZXNbMF0uYm91Z2h0X3RpY2tldHNbdGlja2V0X3R5cGVfaW5kZXhdLm5hdGl2ZQogICAgZnJhbWVfZGlnIDkKICAgIGR1cAogICAgaW50IDQKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBkdXAKICAgIGxlbgogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgLTQKICAgIGludCA4CiAgICAqCiAgICBpbnQgOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTUKICAgICsKICAgIGZyYW1lX2J1cnkgMTAKCmJ1eV90aWNrZXRfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjA5CiAgICAvLyBhc3NlcnQgY291bnQgPD0gdHQubWF4X3Blcl91c2VyLCBPVkVSX01BWF9QRVJfVVNFUgogICAgZnJhbWVfZGlnIDcKICAgIGV4dHJhY3QgNTAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAxMAogICAgaXRvYgogICAgYj49CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJ1eSB0aGF0IGFtb3VudCBvZiB0aWNrZXRzOiBvdmVyIG1heCBwZXIgdXNlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjEwLTIxMQogICAgLy8gIyBzZWF0IG5vdCB0YWtlbgogICAgLy8gc19rZXkgPSBzZWxmLmJveF9rZXlfZnJvbV91aW50NjQoQnl0ZXMoU0VBVFNfQk9YX1BSRUZJWCksIHRpY2tldF90eXBlX2luZGV4KQogICAgYnl0ZSAic2ItIgogICAgZnJhbWVfZGlnIC00CiAgICBjYWxsc3ViIGJveF9rZXlfZnJvbV91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyMTIKICAgIC8vIGlzX3Rha2VuID0gc2VsZi5zZWF0c19jb250YWlucyhzX2tleSwgc2VhdHMpCiAgICBmcmFtZV9kaWcgLTMKICAgIGNhbGxzdWIgc2VhdHNfY29udGFpbnMKICAgIGZyYW1lX2J1cnkgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIxMwogICAgLy8gYXNzZXJ0IG5vdCBpc190YWtlbiwgU0VBVF9UQUtFTgogICAgIQogICAgYXNzZXJ0IC8vIFVuYXZhaWxhYmxlIHNlYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIxNC0yMTYKICAgIC8vICMgcHJvY2VlZCB0byBzZWxsIHRpY2tldHMKICAgIC8vICMgY3JlYXRlIGFzYXMKICAgIC8vIGFiX2tleSA9IHNlbGYuYm94X2tleV9mcm9tX3VpbnQ2NChCeXRlcyhBU1NFVFNfQk9YX1BSRUZJWCksIHRpY2tldF90eXBlX2luZGV4KQogICAgYnl0ZSAiYWItIgogICAgZnJhbWVfZGlnIC00CiAgICBjYWxsc3ViIGJveF9rZXlfZnJvbV91aW50NjQKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjE3CiAgICAvLyBhc3NldHMgPSBBc3NldHNBcnJheSgpCiAgICBieXRlIDB4MDAwMAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyMTgKICAgIC8vIGZvciBpIGluIHVyYW5nZShudW1iZXJfdGlja2V0cyk6CiAgICBpbnQgMAogICAgZnJhbWVfYnVyeSAzCgpidXlfdGlja2V0X2Zvcl9oZWFkZXJAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIxOAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKG51bWJlcl90aWNrZXRzKToKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTUKICAgIDwKICAgIGJ6IGJ1eV90aWNrZXRfYWZ0ZXJfZm9yQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIxOQogICAgLy8gc2VhdCA9IHNlYXRzW2ldLmNvcHkoKQogICAgZnJhbWVfZGlnIC0zCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50IDMyCiAgICAqCiAgICBpbnQgMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjIxCiAgICAvLyB0dC51cmwubmF0aXZlLCB0dC5tZXRhZGF0YV9oYXNoLmNvcHkoKSwgc2VhdAogICAgZnJhbWVfZGlnIDcKICAgIGR1cAogICAgaW50IDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBkdXAKICAgIGxlbgogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgc3Vic3RyaW5nMwogICAgZXh0cmFjdCAyIDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIyMC0yMjIKICAgIC8vIGFzc2V0X2lkID0gc2VsZi5leGVjdXRlX2Fzc2V0X2NyZWF0aW9uX3R4bigKICAgIC8vICAgICB0dC51cmwubmF0aXZlLCB0dC5tZXRhZGF0YV9oYXNoLmNvcHkoKSwgc2VhdAogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGV4ZWN1dGVfYXNzZXRfY3JlYXRpb25fdHhuCiAgICBwb3BuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIyMy0yMjQKICAgIC8vICMgYXBwZW5kIHRvIGJveAogICAgLy8gYXNzZXRzLmFwcGVuZChhcmM0LlVJbnQ2NChhc3NldF9pZCkpCiAgICBmcmFtZV9kaWcgMQogICAgZXh0cmFjdCAyIDAKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludCA4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIxOAogICAgLy8gZm9yIGkgaW4gdXJhbmdlKG51bWJlcl90aWNrZXRzKToKICAgIGludCAxCiAgICArCiAgICBmcmFtZV9idXJ5IDMKICAgIGIgYnV5X3RpY2tldF9mb3JfaGVhZGVyQDMKCmJ1eV90aWNrZXRfYWZ0ZXJfZm9yQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyMjUtMjI2CiAgICAvLyAjIGFwcGVuZCB0byBhc3NldHMgYm94CiAgICAvLyBzZWxmLmFwcGVuZF9hc3NldHNfdG9fYm94KGFiX2tleSwgYXNzZXRzKQogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAxCiAgICBjYWxsc3ViIGFwcGVuZF9hc3NldHNfdG9fYm94CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyMjctMjI4CiAgICAvLyAjIGFwcGVuZCB0byBzZWF0cyBib3gKICAgIC8vIHNlbGYuYXBwZW5kX3NlYXRzX2JveChzX2tleSwgc2VhdHMpCiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIC0zCiAgICBjYWxsc3ViIGFwcGVuZF9zZWF0c19ib3gKICAgIGZyYW1lX2J1cnkgLTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIyOS0yMzEKICAgIC8vICMgYXBwZW5kIHRvIHVzZXIgYm94CiAgICAvLyAjIHBsZWFzZSB1c2UgImZpeC1hcmM0LWR5bmFtaWMtZWxlbWVudC1yZWFkIiBicmFuY2ggZnJvbSBwdXlfYXBpIGdpdGh1YiByZXBvCiAgICAvLyBzZWxmLnVwZGF0ZV9vd25lcl9ib3gob2Jfa2V5LCB0aWNrZXRfdHlwZV9pbmRleCwgc2VhdHMsIGFzc2V0cykKICAgIGZyYW1lX2RpZyA4CiAgICBmcmFtZV9kaWcgLTQKICAgIGZyYW1lX2RpZyAtMwogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHVwZGF0ZV9vd25lcl9ib3gKICAgIHBvcAogICAgZnJhbWVfYnVyeSAtMwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjMyLTIzMwogICAgLy8gIyB1cGRhdGUgdGlja2V0cyBzb2xkCiAgICAvLyBzZWxmLnVwZGF0ZV9zb2xkX3RpY2tldHModHRfa2V5LCB0dCwgbnVtYmVyX3RpY2tldHMpCiAgICBmcmFtZV9kaWcgNgogICAgZnJhbWVfZGlnIDcKICAgIGZyYW1lX2RpZyAtNQogICAgY2FsbHN1YiB1cGRhdGVfc29sZF90aWNrZXRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyMzQtMjM1CiAgICAvLyAjIGVuc3VyZSBhbW91bnQgYW5kIG1icgogICAgLy8gc2VhdHNfY29zdCA9IG51bWJlcl90aWNrZXRzICogdHQucHJpY2UubmF0aXZlCiAgICBleHRyYWN0IDM0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9kaWcgLTUKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIzNgogICAgLy8gYXNzZXJ0IHBheV9hc3NldC54ZmVyX2Fzc2V0ID09IHNlbGYudXNkY19hc3NldCwgV1JPTkdfQVNTRVRfSUQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgWGZlckFzc2V0CiAgICBpbnQgMAogICAgYnl0ZSAidXNkY19hc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdXNkY19hc3NldCBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgQXNzZXQgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjIzNwogICAgLy8gYXNzZXJ0IHBheV9hc3NldC5hc3NldF9hbW91bnQgPj0gc2VhdHNfY29zdCwgQVNTRVRfUEFZTUVOVF9UT09fTE9XCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICA8PQogICAgYXNzZXJ0IC8vIEFzc2V0IHBheW1lbnQgdG9vIGxvdwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjM4CiAgICAvLyBhc3NlcnQgcGF5X2Fzc2V0LmFzc2V0X3JlY2VpdmVyID09IGFwcF9hZGRyLCBXUk9NR19BU1NFVF9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgNAogICAgPT0KICAgIGFzc2VydCAvLyBXcm9uZyBhc3NldCByZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjM5CiAgICAvLyBhc3NlcnQgcGF5X2Fzc2V0LnJla2V5X3RvID09IEdsb2JhbC56ZXJvX2FkZHJlc3MsIFdST05HX1JFX0tFWV9UTwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWtleVRvCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gV3JvbmcgcmUga2V5IHRvLCBzaG91bGQgYmUgemVybyBhZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNDAKICAgIC8vIHBvc3RfbWJyID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNDEKICAgIC8vIHBheV9hbW91bnQgPSBwb3N0X21iciAtIHByZV9tYnIKICAgIGZyYW1lX2RpZyA1CiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNDItMjQ0CiAgICAvLyAjIGluIGNhc2UgbmF0aXZlIGFsZ28gcGF5bWVudAogICAgLy8gIyBwYXlfYW1vdW50ID0gcG9zdF9tYnIgLSBwcmVfbWJyICsgc2VhdHNfY29zdAogICAgLy8gYXNzZXJ0IHBheV9tYnIuYW1vdW50ID49IHBheV9hbW91bnQsIFdST05HX1BBWU1FTlRfQU1PVU5UCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFtb3VudAogICAgPD0KICAgIGFzc2VydCAvLyBXcm9uZyBhbW91bnQgcGF5bWVudAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLmNoZWNrX3N0YXR1c19ub3RfZW5kZWQoKSAtPiB2b2lkOgpjaGVja19zdGF0dXNfbm90X2VuZGVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzM5LTM0MAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBjaGVja19zdGF0dXNfbm90X2VuZGVkKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM0MQogICAgLy8gc2VsZi51cGRhdGVfc3RhdHVzKCkKICAgIGNhbGxzdWIgdXBkYXRlX3N0YXR1cwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzQyCiAgICAvLyBhc3NlcnQgc2VsZi5ldmVudF9zdGF0dXMgIT0gVUludDY0KEVOREVEKSwgRVZFTlRfRU5ERUQKICAgIGludCAwCiAgICBieXRlICJldmVudF9zdGF0dXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIGV2ZW50X3N0YXR1cyBleGlzdHMKICAgIGludCAzCiAgICAhPQogICAgYXNzZXJ0IC8vIEV2ZW50IEVuZGVkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIudXBkYXRlX3N0YXR1cygpIC0+IHZvaWQ6CnVwZGF0ZV9zdGF0dXM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMTQtMzE4CiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgLy8gIyBzdGF0dXMgc3Vicm91dGluZXMgICMKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIHVwZGF0ZV9zdGF0dXMoc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzE5CiAgICAvLyBub3cgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMjAKICAgIC8vIGlmIG5vdyA+IHNlbGYuZXZlbnRfZW5kLnZhbHVlOgogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfZW5kIGV4aXN0cwogICAgPgogICAgYnogdXBkYXRlX3N0YXR1c19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMyMQogICAgLy8gc2VsZi51cGRhdGVfdG8oVUludDY0KEVOREVEKSkKICAgIGludCAzCiAgICBjYWxsc3ViIHVwZGF0ZV90bwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzIyCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKdXBkYXRlX3N0YXR1c19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMjQKICAgIC8vIGlmIG5vdyA+PSBzZWxmLmV2ZW50X2JlZ2luLnZhbHVlOgogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X2JlZ2luIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBldmVudF9iZWdpbiBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICA8PQogICAgYnogdXBkYXRlX3N0YXR1c19hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMyNQogICAgLy8gc2VsZi51cGRhdGVfdG8oVUludDY0KE9OX0dPSU5HKSkKICAgIGludCAyCiAgICBjYWxsc3ViIHVwZGF0ZV90bwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzI2CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKdXBkYXRlX3N0YXR1c19hZnRlcl9pZl9lbHNlQDQ6CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIucmVhZF90aWNrZXRfdHlwZV9ib3goa2V5OiBieXRlcykgLT4gYnl0ZXM6CnJlYWRfdGlja2V0X3R5cGVfYm94OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzYyLTM2MwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiByZWFkX3RpY2tldF90eXBlX2JveChzZWxmLCBrZXk6IEJ5dGVzKSAtPiBUaWNrZXRzVHlwZToKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzY0CiAgICAvLyBiX3ZhbHVlID0gb3AuQm94LmdldChrZXkpCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM2NQogICAgLy8gYXNzZXJ0IGJfdmFsdWVbMV0sIEJPWF9HRVRfRVJST1IKICAgIGFzc2VydCAvLyBGYWlsZWQgdG8gZ2V0IGJveCwgZG9lc24ndCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzY3CiAgICAvLyByZXR1cm4gdmFsdWUKICAgIHJldHN1YgoKCi8vIGFsZ29weS5lbnN1cmVfYnVkZ2V0KHJlcXVpcmVkX2J1ZGdldDogdWludDY0LCBmZWVfc291cmNlOiB1aW50NjQpIC0+IHZvaWQ6CmVuc3VyZV9idWRnZXQ6CiAgICAvLyA8YWxnb3B5Pi9hbGdvcHkucHk6MTEtMTcKICAgIHByb3RvIDIgMAogICAgLy8gPGFsZ29weT4vYWxnb3B5LnB5OjE4CiAgICBmcmFtZV9kaWcgLTIKICAgIGludCAxMAogICAgKwoKZW5zdXJlX2J1ZGdldF93aGlsZV90b3BAMToKICAgIC8vIDxhbGdvcHk+L2FsZ29weS5weToxOQogICAgZnJhbWVfZGlnIDAKICAgIGdsb2JhbCBPcGNvZGVCdWRnZXQKICAgID4KICAgIGJ6IGVuc3VyZV9idWRnZXRfYWZ0ZXJfd2hpbGVANwogICAgLy8gPGFsZ29weT4vYWxnb3B5LnB5OjIwCiAgICBpdHhuX2JlZ2luCiAgICAvLyA8YWxnb3B5Pi9hbGdvcHkucHk6MjEKICAgIGludCBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyA8YWxnb3B5Pi9hbGdvcHkucHk6MjIKICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIC8vIDxhbGdvcHk+L2FsZ29weS5weToyMwogICAgYnl0ZSAweDA2ODEwMQogICAgaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KICAgIC8vIDxhbGdvcHk+L2FsZ29weS5weToyNAogICAgYnl0ZSAweDA2ODEwMQogICAgaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQogICAgLy8gPGFsZ29weT4vYWxnb3B5LnB5OjI1LTI5CiAgICBmcmFtZV9kaWcgLTEKICAgIHN3aXRjaCBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzBAMyBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlXzFANAogICAgYiBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANgoKZW5zdXJlX2J1ZGdldF9zd2l0Y2hfY2FzZV8wQDM6CiAgICAvLyA8YWxnb3B5Pi9hbGdvcHkucHk6MjcKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgYiBlbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANgoKZW5zdXJlX2J1ZGdldF9zd2l0Y2hfY2FzZV8xQDQ6CiAgICAvLyA8YWxnb3B5Pi9hbGdvcHkucHk6MjkKICAgIGdsb2JhbCBNaW5UeG5GZWUKICAgIGl0eG5fZmllbGQgRmVlCgplbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANjoKICAgIC8vIDxhbGdvcHk+L2FsZ29weS5weTozMAogICAgaXR4bl9zdWJtaXQKICAgIGIgZW5zdXJlX2J1ZGdldF93aGlsZV90b3BAMQoKZW5zdXJlX2J1ZGdldF9hZnRlcl93aGlsZUA3OgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLmJveF9rZXlfZnJvbV9hZGRyZXNzKHByZWZpeDogYnl0ZXMsIGFjYzogYnl0ZXMpIC0+IGJ5dGVzOgpib3hfa2V5X2Zyb21fYWRkcmVzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM1Mi0zNTMKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgYm94X2tleV9mcm9tX2FkZHJlc3Moc2VsZiwgcHJlZml4OiBCeXRlcywgYWNjOiBBY2NvdW50KSAtPiBCeXRlczoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzU0CiAgICAvLyByZXR1cm4gb3AuY29uY2F0KHByZWZpeCwgYWNjLmJ5dGVzKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLnJlYWRfb3duZXJfYm94KGtleTogYnl0ZXMpIC0+IGJ5dGVzLCB1aW50NjQ6CnJlYWRfb3duZXJfYm94OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mzg0LTM4NQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiByZWFkX293bmVyX2JveChzZWxmLCBrZXk6IEJ5dGVzKSAtPiB0dXBsZVtPd25lckJveCwgYm9vbF06CiAgICBwcm90byAxIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM4NgogICAgLy8gYl92YWx1ZSA9IG9wLkJveC5nZXQoa2V5KQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozODkKICAgIC8vIHJldHVybiAodmFsdWUuY29weSgpLCBiX3ZhbHVlWzFdKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLnNlYXRzX2NvbnRhaW5zKGtleTogYnl0ZXMsIHJlZl9zZWF0czogYnl0ZXMpIC0+IHVpbnQ2NCwgYnl0ZXM6CnNlYXRzX2NvbnRhaW5zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDU3LTQ1OAogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBzZWF0c19jb250YWlucyhzZWxmLCBrZXk6IEJ5dGVzLCByZWZfc2VhdHM6IFNlYXRzQXJyYXkpIC0+IGJvb2w6CiAgICBwcm90byAyIDIKICAgIGludCAwCiAgICBieXRlICIiCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ1OQogICAgLy8gcl9zZWF0cyA9IG9wLkJveC5nZXQoa2V5KQogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0NjAKICAgIC8vIGlmIG5vdCByX3NlYXRzWzFdOgogICAgYm56IHNlYXRzX2NvbnRhaW5zX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDYxCiAgICAvLyByZXR1cm4gRmFsc2UKICAgIGludCAwCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnNlYXRzX2NvbnRhaW5zX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ2MwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHZhbHVlLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgNQogICAgaW50IDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9idXJ5IDMKICAgIGludCAwCiAgICBmcmFtZV9idXJ5IDEKCnNlYXRzX2NvbnRhaW5zX2Zvcl9oZWFkZXJAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ2MwogICAgLy8gZm9yIGkgaW4gdXJhbmdlKHZhbHVlLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfZGlnIDMKICAgIDwKICAgIGJ6IHNlYXRzX2NvbnRhaW5zX2FmdGVyX2ZvckAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDY0CiAgICAvLyBzID0gdmFsdWVbaV0uY29weSgpCiAgICBmcmFtZV9kaWcgNQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAxCiAgICBpbnQgMzIKICAgICoKICAgIGludCAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ2NQogICAgLy8gZm9yIGogaW4gdXJhbmdlKHJlZl9zZWF0cy5sZW5ndGgpOgogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2J1cnkgNAogICAgaW50IDAKICAgIGZyYW1lX2J1cnkgMgoKc2VhdHNfY29udGFpbnNfZm9yX2hlYWRlckA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDY1CiAgICAvLyBmb3IgaiBpbiB1cmFuZ2UocmVmX3NlYXRzLmxlbmd0aCk6CiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDQKICAgIDwKICAgIGJ6IHNlYXRzX2NvbnRhaW5zX2FmdGVyX2ZvckAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDY2CiAgICAvLyByX3MgPSByZWZfc2VhdHNbal0uY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMgogICAgaW50IDMyCiAgICAqCiAgICBpbnQgMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDY3CiAgICAvLyBpZiBzID09IHJfczoKICAgIGZyYW1lX2RpZyAwCiAgICA9PQogICAgYnogc2VhdHNfY29udGFpbnNfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0NjgKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpzZWF0c19jb250YWluc19hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0NjUKICAgIC8vIGZvciBqIGluIHVyYW5nZShyZWZfc2VhdHMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyAyCiAgICBpbnQgMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIHNlYXRzX2NvbnRhaW5zX2Zvcl9oZWFkZXJANQoKc2VhdHNfY29udGFpbnNfYWZ0ZXJfZm9yQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDYzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UodmFsdWUubGVuZ3RoKToKICAgIGZyYW1lX2RpZyAxCiAgICBpbnQgMQogICAgKwogICAgZnJhbWVfYnVyeSAxCiAgICBiIHNlYXRzX2NvbnRhaW5zX2Zvcl9oZWFkZXJAMwoKc2VhdHNfY29udGFpbnNfYWZ0ZXJfZm9yQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDY5CiAgICAvLyByZXR1cm4gRmFsc2UKICAgIGludCAwCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuZXhlY3V0ZV9hc3NldF9jcmVhdGlvbl90eG4odXJpOiBieXRlcywgbWV0YWRhdGFfaGFzaDogYnl0ZXMsIHNlYXRfYXNfYWRkcjogYnl0ZXMpIC0+IHVpbnQ2NCwgYnl0ZXMsIGJ5dGVzOgpleGVjdXRlX2Fzc2V0X2NyZWF0aW9uX3R4bjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUwMS01MDcKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vICMgQXNhIHN1YnJvdXRpbmVzICMKICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgZXhlY3V0ZV9hc3NldF9jcmVhdGlvbl90eG4oCiAgICAvLyAgICAgc2VsZiwgdXJpOiBTdHJpbmcsIG1ldGFkYXRhX2hhc2g6IEJ5dGVzMzIsIHNlYXRfYXNfYWRkcjogQnl0ZXMzMgogICAgLy8gKSAtPiBVSW50NjQ6CiAgICBwcm90byAzIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUwOAogICAgLy8gYXBwX2FkZHIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTA5LTUyMQogICAgLy8gYXNzZXRfaXR4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgYXNzZXRfbmFtZT1iIkV2ZW50IE5GVCIsCiAgICAvLyAgICAgdW5pdF9uYW1lPWIiRVZULVRDSyIsCiAgICAvLyAgICAgdG90YWw9MSwKICAgIC8vICAgICBkZWNpbWFscz0wLAogICAgLy8gICAgIG1hbmFnZXI9YXBwX2FkZHIsCiAgICAvLyAgICAgcmVzZXJ2ZT1BY2NvdW50LmZyb21fYnl0ZXMoc2VhdF9hc19hZGRyLmJ5dGVzKSwKICAgIC8vICAgICBjbGF3YmFjaz1hcHBfYWRkciwKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1GYWxzZSwKICAgIC8vICAgICB1cmw9dXJpLAogICAgLy8gICAgIG1ldGFkYXRhX2hhc2g9bWV0YWRhdGFfaGFzaC5ieXRlcywKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE1ldGFkYXRhSGFzaAogICAgZnJhbWVfZGlnIC0zCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VVJMCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MTcKICAgIC8vIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXREZWZhdWx0RnJvemVuCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRDbGF3YmFjawogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUxMwogICAgLy8gZGVjaW1hbHM9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUxMgogICAgLy8gdG90YWw9MSwKICAgIGludCAxCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUxMQogICAgLy8gdW5pdF9uYW1lPWIiRVZULVRDSyIsCiAgICBieXRlICJFVlQtVENLIgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVuaXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MTAKICAgIC8vIGFzc2V0X25hbWU9YiJFdmVudCBORlQiLAogICAgYnl0ZSAiRXZlbnQgTkZUIgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUwOQogICAgLy8gYXNzZXRfaXR4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICBpbnQgYWNmZwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTIwCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTA5LTUyMQogICAgLy8gYXNzZXRfaXR4biA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgYXNzZXRfbmFtZT1iIkV2ZW50IE5GVCIsCiAgICAvLyAgICAgdW5pdF9uYW1lPWIiRVZULVRDSyIsCiAgICAvLyAgICAgdG90YWw9MSwKICAgIC8vICAgICBkZWNpbWFscz0wLAogICAgLy8gICAgIG1hbmFnZXI9YXBwX2FkZHIsCiAgICAvLyAgICAgcmVzZXJ2ZT1BY2NvdW50LmZyb21fYnl0ZXMoc2VhdF9hc19hZGRyLmJ5dGVzKSwKICAgIC8vICAgICBjbGF3YmFjaz1hcHBfYWRkciwKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1GYWxzZSwKICAgIC8vICAgICB1cmw9dXJpLAogICAgLy8gICAgIG1ldGFkYXRhX2hhc2g9bWV0YWRhdGFfaGFzaC5ieXRlcywKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIENyZWF0ZWRBc3NldElECiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MjIKICAgIC8vIHJldHVybiBhc3NldF9pdHhuLmNyZWF0ZWRfYXNzZXQuaWQKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuYXBwZW5kX2Fzc2V0c190b19ib3goa2V5OiBieXRlcywgYXNzZXRzX2lkczogYnl0ZXMpIC0+IGJ5dGVzOgphcHBlbmRfYXNzZXRzX3RvX2JveDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ5MC00OTEKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgYXBwZW5kX2Fzc2V0c190b19ib3goc2VsZiwga2V5OiBCeXRlcywgYXNzZXRzX2lkczogQXNzZXRzQXJyYXkpIC0+IE5vbmU6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ5MgogICAgLy8gYl9hc3NldHMgPSBvcC5Cb3guZ2V0KGtleSkKICAgIGZyYW1lX2RpZyAtMgogICAgYm94X2dldAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDkzCiAgICAvLyBpZiBub3QgYl9hc3NldHNbMV06CiAgICBibnogYXBwZW5kX2Fzc2V0c190b19ib3hfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ5NAogICAgLy8gb3AuQm94LnB1dChrZXksIGFzc2V0c19pZHMuYnl0ZXMpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgYm94X3B1dAogICAgYiBhcHBlbmRfYXNzZXRzX3RvX2JveF9hZnRlcl9pZl9lbHNlQDMKCmFwcGVuZF9hc3NldHNfdG9fYm94X2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDk3CiAgICAvLyBhcnIuZXh0ZW5kKGFzc2V0c19pZHMpCiAgICBmcmFtZV9kaWcgMAogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyIDAKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludCA4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0OTgKICAgIC8vIG9wLkJveC5kZWxldGUoa2V5KQogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ5OQogICAgLy8gb3AuQm94LnB1dChrZXksIGFyci5ieXRlcykKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgYm94X3B1dAoKYXBwZW5kX2Fzc2V0c190b19ib3hfYWZ0ZXJfaWZfZWxzZUAzOgogICAgZnJhbWVfZGlnIC0xCiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuYXBwZW5kX3NlYXRzX2JveChrZXk6IGJ5dGVzLCBzZWF0czogYnl0ZXMpIC0+IGJ5dGVzOgphcHBlbmRfc2VhdHNfYm94OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDQ1LTQ0NgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBhcHBlbmRfc2VhdHNfYm94KHNlbGYsIGtleTogQnl0ZXMsIHNlYXRzOiBTZWF0c0FycmF5KSAtPiBOb25lOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0NDcKICAgIC8vIGJfc2VhdHMgPSBvcC5Cb3guZ2V0KGtleSkKICAgIGZyYW1lX2RpZyAtMgogICAgYm94X2dldAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDQ4CiAgICAvLyBpZiBub3QgYl9zZWF0c1sxXToKICAgIGJueiBhcHBlbmRfc2VhdHNfYm94X2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0NDkKICAgIC8vIG9wLkJveC5wdXQoa2V5LCBzZWF0cy5ieXRlcykKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfcHV0CiAgICBiIGFwcGVuZF9zZWF0c19ib3hfYWZ0ZXJfaWZfZWxzZUAzCgphcHBlbmRfc2VhdHNfYm94X2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDUyCiAgICAvLyBhcnIuZXh0ZW5kKHNlYXRzKQogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBpbnQgMzIKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQ1My00NTQKICAgIC8vICMgVE9ETyBjaGFuZ2UgdG8gcmVzaXplID8/PwogICAgLy8gb3AuQm94LmRlbGV0ZShrZXkpCiAgICBmcmFtZV9kaWcgLTIKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDU1CiAgICAvLyBvcC5Cb3gucHV0KGtleSwgYXJyLmJ5dGVzKQogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBib3hfcHV0CgphcHBlbmRfc2VhdHNfYm94X2FmdGVyX2lmX2Vsc2VAMzoKICAgIGZyYW1lX2RpZyAtMQogICAgc3dhcAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLnVwZGF0ZV9vd25lcl9ib3goa2V5OiBieXRlcywgdGlja2V0X3R5cGVfaW5kZXg6IHVpbnQ2NCwgc2VhdHM6IGJ5dGVzLCBhc3NldHNfaWRzOiBieXRlcykgLT4gYnl0ZXMsIGJ5dGVzOgp1cGRhdGVfb3duZXJfYm94OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mzk2LTQwMwogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiB1cGRhdGVfb3duZXJfYm94KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAga2V5OiBCeXRlcywKICAgIC8vICAgICB0aWNrZXRfdHlwZV9pbmRleDogVUludDY0LAogICAgLy8gICAgIHNlYXRzOiBTZWF0c0FycmF5LAogICAgLy8gICAgIGFzc2V0c19pZHM6IEFzc2V0c0FycmF5LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNCAyCiAgICBpbnQgMAogICAgYnl0ZSAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MDQKICAgIC8vIGFzc2VydCBzZWF0cy5sZW5ndGggPT0gYXNzZXRzX2lkcy5sZW5ndGgsICJsZW5ndGhzIG11c3QgbWF0Y2giCiAgICBmcmFtZV9kaWcgLTIKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgPT0KICAgIGFzc2VydCAvLyBsZW5ndGhzIG11c3QgbWF0Y2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQwNQogICAgLy8gYl9vd25lciA9IG9wLkJveC5nZXQoa2V5KQogICAgZnJhbWVfZGlnIC00CiAgICBib3hfZ2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MDYKICAgIC8vIGlmIG5vdCBiX293bmVyWzFdOgogICAgYm56IHVwZGF0ZV9vd25lcl9ib3hfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQwNwogICAgLy8gYl90ID0gQm91Z2h0VGlja2V0c0FycmF5KCkKICAgIGJ5dGUgMHgwMDAwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQwOAogICAgLy8gZm9yIF9pIGluIHVyYW5nZShzZWxmLmxhc3RfdHlwZV9pbmRleCk6CiAgICBpbnQgMAogICAgYnl0ZSAibGFzdF90eXBlX2luZGV4IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMgogICAgYXNzZXJ0IC8vIGNoZWNrIGxhc3RfdHlwZV9pbmRleCBleGlzdHMKICAgIGludCAwCiAgICBmcmFtZV9idXJ5IDEKCnVwZGF0ZV9vd25lcl9ib3hfZm9yX2hlYWRlckAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDA4CiAgICAvLyBmb3IgX2kgaW4gdXJhbmdlKHNlbGYubGFzdF90eXBlX2luZGV4KToKICAgIGZyYW1lX2RpZyAxCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogdXBkYXRlX293bmVyX2JveF9hZnRlcl9mb3JANgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDA5CiAgICAvLyBiX3QuYXBwZW5kKGFyYzQuVUludDY0KDApKQogICAgZnJhbWVfZGlnIDAKICAgIGV4dHJhY3QgMiAwCiAgICBieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaW50IDgKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAwCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDA4CiAgICAvLyBmb3IgX2kgaW4gdXJhbmdlKHNlbGYubGFzdF90eXBlX2luZGV4KToKICAgIGZyYW1lX2RpZyAxCiAgICBpbnQgMQogICAgKwogICAgZnJhbWVfYnVyeSAxCiAgICBiIHVwZGF0ZV9vd25lcl9ib3hfZm9yX2hlYWRlckAyCgp1cGRhdGVfb3duZXJfYm94X2FmdGVyX2ZvckA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDEwCiAgICAvLyBiX3RbdGlja2V0X3R5cGVfaW5kZXhdID0gYXJjNC5VSW50NjQoc2VhdHMubGVuZ3RoKQogICAgZnJhbWVfZGlnIDMKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIC0zCiAgICA+CiAgICBhc3NlcnQgLy8gSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtMwogICAgaW50IDgKICAgICoKICAgIGludCAyCiAgICArCiAgICB1bmNvdmVyIDIKICAgIHJlcGxhY2UzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MTEKICAgIC8vIF9ib3ggPSBPd25lckJveChzZWF0cz1zZWF0cywgYXNzZXRzPWFzc2V0c19pZHMsIGJvdWdodF90aWNrZXRzPWJfdCkKICAgIGZyYW1lX2RpZyAtMgogICAgbGVuCiAgICBpbnQgNgogICAgKwogICAgZHVwCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgYnl0ZSAweDAwMDYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MTIKICAgIC8vIG9wLkJveC5wdXQoa2V5LCBfYm94LmJ5dGVzKQogICAgZnJhbWVfZGlnIC00CiAgICBzd2FwCiAgICBib3hfcHV0CiAgICBiIHVwZGF0ZV9vd25lcl9ib3hfYWZ0ZXJfaWZfZWxzZUA4Cgp1cGRhdGVfb3duZXJfYm94X2Vsc2VfYm9keUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDE1CiAgICAvLyBiX3QgPSBfYm94LmJvdWdodF90aWNrZXRzLmNvcHkoKQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgaW50IDQKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBkdXAKICAgIGxlbgogICAgc3dhcAogICAgZHVwCiAgICBkaWcgMwogICAgdW5jb3ZlciAzCiAgICBzdWJzdHJpbmczCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MTYKICAgIC8vIHByZXZfYl90ID0gYl90W3RpY2tldF90eXBlX2luZGV4XQogICAgZHVwCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIC0zCiAgICBpbnQgOAogICAgKgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpbnQgOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MTcKICAgIC8vIGJfdFt0aWNrZXRfdHlwZV9pbmRleF0gPSBhcmM0LlVJbnQ2NChzZWF0cy5sZW5ndGggKyBwcmV2X2JfdC5uYXRpdmUpCiAgICBidG9pCiAgICBmcmFtZV9kaWcgMwogICAgKwogICAgaXRvYgogICAgZGlnIDEKICAgIGludCAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIC0zCiAgICA+CiAgICBhc3NlcnQgLy8gSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHVuY292ZXIgMgogICAgaW50IDIKICAgICsKICAgIHN3YXAKICAgIHJlcGxhY2UzCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MTgKICAgIC8vIF9zID0gX2JveC5zZWF0cy5jb3B5KCkKICAgIGR1cAogICAgaW50IDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBkdXAKICAgIGludCAyCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIHVuY292ZXIgMwogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjQxOQogICAgLy8gX3MuZXh0ZW5kKHNlYXRzKQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAyIDAKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludCAzMgogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDIwCiAgICAvLyBfYSA9IF9ib3guYXNzZXRzLmNvcHkoKQogICAgdW5jb3ZlciAzCiAgICBzdWJzdHJpbmczCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MjEKICAgIC8vIF9hLmV4dGVuZChhc3NldHNfaWRzKQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyIDAKICAgIGNvbmNhdAogICAgZHVwCiAgICBsZW4KICAgIGludCA4CiAgICAvCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MjIKICAgIC8vIF9uZXdfYm94ID0gT3duZXJCb3goc2VhdHM9X3MsIGFzc2V0cz1fYSwgYm91Z2h0X3RpY2tldHM9Yl90KQogICAgZGlnIDEKICAgIGxlbgogICAgaW50IDYKICAgICsKICAgIGR1cAogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGJ5dGUgMHgwMDA2CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGRpZyAyCiAgICBsZW4KICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NDIzCiAgICAvLyBvcC5Cb3guZGVsZXRlKGtleSkKICAgIGZyYW1lX2RpZyAtNAogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo0MjQKICAgIC8vIG9wLkJveC5wdXQoa2V5LCBfbmV3X2JveC5ieXRlcykKICAgIGZyYW1lX2RpZyAtNAogICAgc3dhcAogICAgYm94X3B1dAoKdXBkYXRlX293bmVyX2JveF9hZnRlcl9pZl9lbHNlQDg6CiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfYnVyeSAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci51cGRhdGVfc29sZF90aWNrZXRzKGtleTogYnl0ZXMsIHR0OiBieXRlcywgYW1vdW50X3RvX2FkZDogdWludDY0KSAtPiBieXRlczoKdXBkYXRlX3NvbGRfdGlja2V0czoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjM2OS0zNzIKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgdXBkYXRlX3NvbGRfdGlja2V0cygKICAgIC8vICAgICBzZWxmLCBrZXk6IEJ5dGVzLCB0dDogVGlja2V0c1R5cGUsIGFtb3VudF90b19hZGQ6IFVJbnQ2NAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozNzMKICAgIC8vIG9sZF9hbW91bnQgPSB0dC5zb2xkX2Ftb3VudC5uYXRpdmUKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCA1OCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mzc0CiAgICAvLyBuZXdfYW1vdW50ID0gb2xkX2Ftb3VudCArIGFtb3VudF90b19hZGQKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mzc1CiAgICAvLyB0dC5zb2xkX2Ftb3VudCA9IGFyYzQuVUludDY0KG5ld19hbW91bnQpCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIHJlcGxhY2UyIDU4CiAgICBmcmFtZV9idXJ5IC0yCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozNzYKICAgIC8vIG9wLkJveC5yZXBsYWNlKGtleSwgMCwgdHQuYnl0ZXMpCiAgICBmcmFtZV9kaWcgLTMKICAgIGludCAwCiAgICBmcmFtZV9kaWcgLTIKICAgIGJveF9yZXBsYWNlCiAgICBmcmFtZV9kaWcgLTIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci5jbGFpbV9hc3NldChvd25lcjogYnl0ZXMsIGFzc2V0X2lkOiB1aW50NjQpIC0+IHZvaWQ6CmNsYWltX2Fzc2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjQ2LTI0NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICAvLyBkZWYgY2xhaW1fYXNzZXQoc2VsZiwgb3duZXI6IEFjY291bnQsIGFzc2V0X2lkOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI0OAogICAgLy8gc2VsZi51cGRhdGVfc3RhdHVzKCkKICAgIGNhbGxzdWIgdXBkYXRlX3N0YXR1cwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjQ5LTI1MAogICAgLy8gIyBjaGVjayBvd25lciBpcyBjb3JyZWN0CiAgICAvLyBpc19vd25lciA9IHNlbGYuY2hlY2tfb3duZXJfYXNzZXQob3duZXIsIGFzc2V0X2lkKQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgY2hlY2tfb3duZXJfYXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI1MQogICAgLy8gYXNzZXJ0IGlzX293bmVyLCBOT1RfQVNTRVRfT1dORVIKICAgIGFzc2VydCAvLyBOb3QgYXNzZXQgb3duZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI1Mi0yNTMKICAgIC8vICMgdHJhbnNmZXIgYXNzZXQKICAgIC8vIGFwcF9hZGRyID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI1NC0yNjAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MSwKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0X2lkLAogICAgLy8gICAgIHNlbmRlcj1hcHBfYWRkciwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1vd25lciwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjU1CiAgICAvLyBhc3NldF9hbW91bnQ9MSwKICAgIGludCAxCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNTQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludCBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjU5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjU0LTI2MAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXRfaWQsCiAgICAvLyAgICAgc2VuZGVyPWFwcF9hZGRyLAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPW93bmVyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI2MQogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuY2hlY2tfb3duZXJfYXNzZXQob3duZXI6IGJ5dGVzLCBhc3NldF9pZDogdWludDY0KSAtPiB1aW50NjQ6CmNoZWNrX293bmVyX2Fzc2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTI0LTUyNQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBjaGVja19vd25lcl9hc3NldChzZWxmLCBvd25lcjogQWNjb3VudCwgYXNzZXRfaWQ6IFVJbnQ2NCkgLT4gYm9vbDoKICAgIHByb3RvIDIgMQogICAgYnl0ZSAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTI2CiAgICAvLyBvYl9rZXkgPSBzZWxmLmJveF9rZXlfZnJvbV9hZGRyZXNzKEJ5dGVzKE9XTkVSX0JPWF9QUkVGSVgpLCBvd25lcikKICAgIGJ5dGUgIm90LSIKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBib3hfa2V5X2Zyb21fYWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTI3CiAgICAvLyBvYl9yZXMgPSBzZWxmLnJlYWRfb3duZXJfYm94KG9iX2tleSkKICAgIGNhbGxzdWIgcmVhZF9vd25lcl9ib3gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUyOAogICAgLy8gYXNzZXJ0IG9iX3Jlc1sxXSwgVVNFUl9ET0VTTlRfRVhJU1QKICAgIGFzc2VydCAvLyBVc2VyIGRvZXNuJ3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUyOQogICAgLy8gYXNzZXRzID0gb2JfcmVzWzBdLmFzc2V0cy5jb3B5KCkKICAgIGR1cAogICAgaW50IDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBkdXAKICAgIGludCA0CiAgICBleHRyYWN0X3VpbnQxNgogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTMwCiAgICAvLyBmb3VuZCA9IEZhbHNlCiAgICBpbnQgMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6NTMxCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UoYXNzZXRzLmxlbmd0aCk6CiAgICBpbnQgMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludCAwCgpjaGVja19vd25lcl9hc3NldF9mb3JfaGVhZGVyQDE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MzEKICAgIC8vIGZvciBpIGluIHVyYW5nZShhc3NldHMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgMwogICAgPAogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2J1cnkgMAogICAgYnogY2hlY2tfb3duZXJfYXNzZXRfYWZ0ZXJfZm9yQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUzMgogICAgLy8gaWYgYXNzZXRzW2ldID09IGFzc2V0X2lkOgogICAgZnJhbWVfZGlnIDEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgNAogICAgaW50IDgKICAgICoKICAgIGludCA4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYj09CiAgICBieiBjaGVja19vd25lcl9hc3NldF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjUzMwogICAgLy8gZm91bmQgPSBUcnVlCiAgICBpbnQgMQogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MzQKICAgIC8vIGJyZWFrCiAgICBiIGNoZWNrX293bmVyX2Fzc2V0X2FmdGVyX2ZvckA3CgpjaGVja19vd25lcl9hc3NldF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MzEKICAgIC8vIGZvciBpIGluIHVyYW5nZShhc3NldHMubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBpbnQgMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIGNoZWNrX293bmVyX2Fzc2V0X2Zvcl9oZWFkZXJAMQoKY2hlY2tfb3duZXJfYXNzZXRfYWZ0ZXJfZm9yQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTo1MzUKICAgIC8vIHJldHVybiBmb3VuZAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLmZyZWV6ZV9hc3NldChvd25lcjogYnl0ZXMsIGFzc2V0X2lkOiB1aW50NjQsIHNlYXQ6IGJ5dGVzKSAtPiB2b2lkOgpmcmVlemVfYXNzZXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNjMtMjY0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiBmcmVlemVfYXNzZXQoc2VsZiwgb3duZXI6IEFjY291bnQsIGFzc2V0X2lkOiBVSW50NjQsIHNlYXQ6IEJ5dGVzMzIpIC0+IE5vbmU6CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI2NS0yNjYKICAgIC8vICMgb25seSBldmVudCBvd25lcgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5ldmVudF9vd25lci52YWx1ZSwgT05MWV9FVkVOVF9PV05FUgogICAgdHhuIFNlbmRlcgogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X293bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBldmVudF9vd25lciBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBvd25lcgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjY3LTI3MwogICAgLy8gIyBhcHBfYWRkciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICAvLyAgICAgZnJlZXplX2Fzc2V0PWFzc2V0X2lkLAogICAgLy8gICAgIGZyb3plbj1UcnVlLAogICAgLy8gICAgIGZyZWV6ZV9hY2NvdW50PW93bmVyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0zCiAgICBpdHhuX2ZpZWxkIEZyZWV6ZUFzc2V0QWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjcwCiAgICAvLyBmcm96ZW49VHJ1ZSwKICAgIGludCAxCiAgICBpdHhuX2ZpZWxkIEZyZWV6ZUFzc2V0RnJvemVuCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI2Ny0yNjgKICAgIC8vICMgYXBwX2FkZHIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgaW50IGFmcnoKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI3MgogICAgLy8gZmVlPTAsCiAgICBpbnQgMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI2Ny0yNzMKICAgIC8vICMgYXBwX2FkZHIgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyBpdHhuLkFzc2V0RnJlZXplKAogICAgLy8gICAgIGZyZWV6ZV9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBmcm96ZW49VHJ1ZSwKICAgIC8vICAgICBmcmVlemVfYWNjb3VudD1vd25lciwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNzQKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLnVuX2ZyZWV6ZV9hc3NldChvd25lcjogYnl0ZXMsIGFzc2V0X2lkOiB1aW50NjQsIHNlYXQ6IGJ5dGVzKSAtPiB2b2lkOgp1bl9mcmVlemVfYXNzZXQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyNzYtMjc3CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiB1bl9mcmVlemVfYXNzZXQoc2VsZiwgb3duZXI6IEFjY291bnQsIGFzc2V0X2lkOiBVSW50NjQsIHNlYXQ6IEJ5dGVzMzIpIC0+IE5vbmU6CiAgICBwcm90byAzIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI3OAogICAgLy8gc2VsZi51cGRhdGVfc3RhdHVzKCkKICAgIGNhbGxzdWIgdXBkYXRlX3N0YXR1cwogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjc5LTI4MAogICAgLy8gIyBldmVudCBlbmRlZAogICAgLy8gYXNzZXJ0IHNlbGYuZXZlbnRfc3RhdHVzID09IFVJbnQ2NChFTkRFRCksIEVWRU5UX05PVF9FTkRFRAogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X3N0YXR1cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfc3RhdHVzIGV4aXN0cwogICAgaW50IDMKICAgID09CiAgICBhc3NlcnQgLy8gRXZlbnQgbm90IEVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyODEtMjgyCiAgICAvLyAjIGNoZWNrIG93bmVyIGlzIGNvcnJlY3QKICAgIC8vIGlzX293bmVyID0gc2VsZi5jaGVja19vd25lcl9hc3NldChvd25lciwgYXNzZXRfaWQpCiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyAtMgogICAgY2FsbHN1YiBjaGVja19vd25lcl9hc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MjgzCiAgICAvLyBhc3NlcnQgaXNfb3duZXIsIE5PVF9BU1NFVF9PV05FUgogICAgYXNzZXJ0IC8vIE5vdCBhc3NldCBvd25lcgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjg0LTI5MAogICAgLy8gIyBhcHBfYWRkciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICAvLyAgICAgZnJlZXplX2Fzc2V0PWFzc2V0X2lkLAogICAgLy8gICAgIGZyb3plbj1GYWxzZSwKICAgIC8vICAgICBmcmVlemVfYWNjb3VudD1vd25lciwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMwogICAgaXR4bl9maWVsZCBGcmVlemVBc3NldEFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI4NwogICAgLy8gZnJvemVuPUZhbHNlLAogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRnJlZXplQXNzZXRGcm96ZW4KICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBGcmVlemVBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjg0LTI4NQogICAgLy8gIyBhcHBfYWRkciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICBpbnQgYWZyegogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjg5CiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjg0LTI5MAogICAgLy8gIyBhcHBfYWRkciA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vIGl0eG4uQXNzZXRGcmVlemUoCiAgICAvLyAgICAgZnJlZXplX2Fzc2V0PWFzc2V0X2lkLAogICAgLy8gICAgIGZyb3plbj1GYWxzZSwKICAgIC8vICAgICBmcmVlemVfYWNjb3VudD1vd25lciwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyOTEKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmV2ZW50X21hbmFnZXIuY29udHJhY3QuRXZlbnRNYW5hZ2VyLndpdGhkcmF3KCkgLT4gdm9pZDoKd2l0aGRyYXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyOTMtMjk0CiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIC8vIGRlZiB3aXRoZHJhdyhzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyOTUKICAgIC8vIHNlbGYudXBkYXRlX3N0YXR1cygpCiAgICBjYWxsc3ViIHVwZGF0ZV9zdGF0dXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI5NgogICAgLy8gYXNzZXJ0IHNlbGYuZXZlbnRfc3RhdHVzID09IFVJbnQ2NChFTkRFRCksIEVWRU5UX05PVF9FTkRFRAogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X3N0YXR1cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfc3RhdHVzIGV4aXN0cwogICAgaW50IDMKICAgID09CiAgICBhc3NlcnQgLy8gRXZlbnQgbm90IEVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToyOTcKICAgIC8vIGFwcF9hZGRyID0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI5OAogICAgLy8gYW1vdW50ID0gYXBwX2FkZHIuYmFsYW5jZSAtIGFwcF9hZGRyLm1pbl9iYWxhbmNlCiAgICBkdXAKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgc3dhcAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBkdXAKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI5OS0zMDQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuZXZlbnRfb3duZXIudmFsdWUsCiAgICAvLyAgICAgc2VuZGVyPWFwcF9hZGRyLAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzAxCiAgICAvLyByZWNlaXZlcj1zZWxmLmV2ZW50X293bmVyLnZhbHVlLAogICAgaW50IDAKICAgIGJ5dGUgImV2ZW50X293bmVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBldmVudF9vd25lciBleGlzdHMKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjI5OQogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50IHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzAzCiAgICAvLyBmZWU9MCwKICAgIGludCAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6Mjk5LTMwNAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5ldmVudF9vd25lci52YWx1ZSwKICAgIC8vICAgICBzZW5kZXI9YXBwX2FkZHIsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzA1CiAgICAvLyBhcHBfYXNzZXRfYmFsID0gc2VsZi51c2RjX2Fzc2V0LmJhbGFuY2UoYXBwX2FkZHIpCiAgICBpbnQgMAogICAgYnl0ZSAidXNkY19hc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdXNkY19hc3NldCBleGlzdHMKICAgIGRpZyAxCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMwNi0zMTEKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PXNlbGYudXNkY19hc3NldCwKICAgIC8vICAgICBzZW5kZXI9YXBwX2FkZHIsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9c2VsZi5ldmVudF9vd25lci52YWx1ZSwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YXBwX2Fzc2V0X2JhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMwNwogICAgLy8geGZlcl9hc3NldD1zZWxmLnVzZGNfYXNzZXQsCiAgICBpbnQgMAogICAgYnl0ZSAidXNkY19hc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgdXNkY19hc3NldCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjMwOQogICAgLy8gYXNzZXRfcmVjZWl2ZXI9c2VsZi5ldmVudF9vd25lci52YWx1ZSwKICAgIGludCAwCiAgICBieXRlICJldmVudF9vd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgZXZlbnRfb3duZXIgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMDYKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludCBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50IDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weTozMDYtMzExCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1zZWxmLnVzZGNfYXNzZXQsCiAgICAvLyAgICAgc2VuZGVyPWFwcF9hZGRyLAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXNlbGYuZXZlbnRfb3duZXIudmFsdWUsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFwcF9hc3NldF9iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MzEyCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5ldmVudF9tYW5hZ2VyLmNvbnRyYWN0LkV2ZW50TWFuYWdlci5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTAzCiAgICAvLyBkZWYgX19pbml0X18oc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTA0CiAgICAvLyBzZWxmLm5hbWUgPSBTdHJpbmcoKQogICAgYnl0ZSAibmFtZSIKICAgIGJ5dGUgIiIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMDUKICAgIC8vIHNlbGYuZXZlbnRfYmVnaW4gPSBHbG9iYWxTdGF0ZShVSW50NjQoMCksIGRlc2NyaXB0aW9uPSJFdmVudCBiZWdpbiB0aW1lc3RhbXAiKQogICAgYnl0ZSAiZXZlbnRfYmVnaW4iCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEwNgogICAgLy8gc2VsZi5ldmVudF9lbmQgPSBHbG9iYWxTdGF0ZShVSW50NjQoMCksIGRlc2NyaXB0aW9uPSJFdmVudCBlbmQgdGltZXN0YW1wIikKICAgIGJ5dGUgImV2ZW50X2VuZCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTA3CiAgICAvLyBzZWxmLmV2ZW50X293bmVyID0gR2xvYmFsU3RhdGUoR2xvYmFsLnplcm9fYWRkcmVzcywgZGVzY3JpcHRpb249IkV2ZW50IG93bmVyIikKICAgIGJ5dGUgImV2ZW50X293bmVyIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTA4CiAgICAvLyBzZWxmLnVzZGNfYXNzZXQgPSBBc3NldCgpCiAgICBieXRlICJ1c2RjX2Fzc2V0IgogICAgaW50IDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXZlbnRfbWFuYWdlci9jb250cmFjdC5weToxMDkKICAgIC8vIHNlbGYuZXZlbnRfc3RhdHVzID0gVUludDY0KElOSVQpCiAgICBieXRlICJldmVudF9zdGF0dXMiCiAgICBpbnQgMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjExMAogICAgLy8gc2VsZi5sYXN0X3R5cGVfaW5kZXggPSBVSW50NjQoMCkKICAgIGJ5dGUgImxhc3RfdHlwZV9pbmRleCIKICAgIGludCAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2V2ZW50X21hbmFnZXIvY29udHJhY3QucHk6MTExCiAgICAvLyBsb2coQVBQX0NSRUFURUQpCiAgICBieXRlICJbRVZFTlQgTUFOQUdFUl0gQ3JlYXRlZCIKICAgIGxvZwogICAgcmV0c3ViCg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuZXZlbnRfbWFuYWdlci5jb250cmFjdC5FdmVudE1hbmFnZXIuY2xlYXJfc3RhdGVfcHJvZ3JhbToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9ldmVudF9tYW5hZ2VyL2NvbnRyYWN0LnB5OjEwMgogICAgLy8gY2xhc3MgRXZlbnRNYW5hZ2VyKEFSQzRDb250cmFjdCk6CiAgICBpbnQgMQogICAgcmV0dXJuCg=="
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 5
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "schema": {
    "global": {
      "declared": {
        "event_begin": {
          "type": "uint64",
          "key": "event_begin",
          "descr": "Event begin timestamp"
        },
        "event_end": {
          "type": "uint64",
          "key": "event_end",
          "descr": "Event end timestamp"
        },
        "event_owner": {
          "type": "bytes",
          "key": "event_owner",
          "descr": "Event owner"
        },
        "event_status": {
          "type": "uint64",
          "key": "event_status"
        },
        "last_type_index": {
          "type": "uint64",
          "key": "last_type_index"
        },
        "name": {
          "type": "bytes",
          "key": "name"
        },
        "usdc_asset": {
          "type": "uint64",
          "key": "usdc_asset"
        }
      },
      "reserved": {}
    },
    "local": {
      "declared": {},
      "reserved": {}
    }
  },
  "contract": {
    "name": "EventManager",
    "methods": [
      {
        "name": "start_event",
        "args": [
          {
            "type": "string",
            "name": "name"
          },
          {
            "type": "account",
            "name": "owner"
          },
          {
            "type": "asset",
            "name": "usdc_asset"
          },
          {
            "type": "uint64",
            "name": "begin_ts"
          },
          {
            "type": "uint64",
            "name": "end_ts"
          },
          {
            "type": "string[]",
            "name": "tt_urls"
          },
          {
            "type": "byte[32][]",
            "name": "tt_hash"
          },
          {
            "type": "uint64[]",
            "name": "tt_prices"
          },
          {
            "type": "uint64[]",
            "name": "tt_supply"
          },
          {
            "type": "uint64[]",
            "name": "tt_max_per_user"
          },
          {
            "type": "uint64[]",
            "name": "tt_sold_amount"
          },
          {
            "type": "pay",
            "name": "pay_mbr"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "buy_ticket",
        "args": [
          {
            "type": "account",
            "name": "owner"
          },
          {
            "type": "uint64",
            "name": "number_tickets"
          },
          {
            "type": "uint64",
            "name": "ticket_type_index"
          },
          {
            "type": "byte[32][]",
            "name": "seats"
          },
          {
            "type": "pay",
            "name": "pay_mbr"
          },
          {
            "type": "axfer",
            "name": "pay_asset"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "claim_asset",
        "args": [
          {
            "type": "account",
            "name": "owner"
          },
          {
            "type": "uint64",
            "name": "asset_id"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "freeze_asset",
        "args": [
          {
            "type": "account",
            "name": "owner"
          },
          {
            "type": "uint64",
            "name": "asset_id"
          },
          {
            "type": "byte[32]",
            "name": "seat"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "un_freeze_asset",
        "args": [
          {
            "type": "account",
            "name": "owner"
          },
          {
            "type": "uint64",
            "name": "asset_id"
          },
          {
            "type": "byte[32]",
            "name": "seat"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "withdraw",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ],
    "networks": {}
  },
  "bare_call_config": {
    "no_op": "CREATE"
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the EventManager smart contract.
 */
export type EventManager = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void' | 'start_event', {
      argsObj: {
        name: string
        owner: string | Uint8Array
        usdcAsset: number | bigint
        beginTs: bigint | number
        endTs: bigint | number
        ttUrls: string[]
        ttHash: Uint8Array[]
        ttPrices: bigint | number[]
        ttSupply: bigint | number[]
        ttMaxPerUser: bigint | number[]
        ttSoldAmount: bigint | number[]
        payMbr: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [name: string, owner: string | Uint8Array, usdcAsset: number | bigint, beginTs: bigint | number, endTs: bigint | number, ttUrls: string[], ttHash: Uint8Array[], ttPrices: bigint | number[], ttSupply: bigint | number[], ttMaxPerUser: bigint | number[], ttSoldAmount: bigint | number[], payMbr: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void' | 'buy_ticket', {
      argsObj: {
        owner: string | Uint8Array
        numberTickets: bigint | number
        ticketTypeIndex: bigint | number
        seats: Uint8Array[]
        payMbr: TransactionToSign | Transaction | Promise<SendTransactionResult>
        payAsset: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [owner: string | Uint8Array, numberTickets: bigint | number, ticketTypeIndex: bigint | number, seats: Uint8Array[], payMbr: TransactionToSign | Transaction | Promise<SendTransactionResult>, payAsset: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'claim_asset(account,uint64)void' | 'claim_asset', {
      argsObj: {
        owner: string | Uint8Array
        assetId: bigint | number
      }
      argsTuple: [owner: string | Uint8Array, assetId: bigint | number]
      returns: void
    }>
    & Record<'freeze_asset(account,uint64,byte[32])void' | 'freeze_asset', {
      argsObj: {
        owner: string | Uint8Array
        assetId: bigint | number
        seat: Uint8Array
      }
      argsTuple: [owner: string | Uint8Array, assetId: bigint | number, seat: Uint8Array]
      returns: void
    }>
    & Record<'un_freeze_asset(account,uint64,byte[32])void' | 'un_freeze_asset', {
      argsObj: {
        owner: string | Uint8Array
        assetId: bigint | number
        seat: Uint8Array
      }
      argsTuple: [owner: string | Uint8Array, assetId: bigint | number, seat: Uint8Array]
      returns: void
    }>
    & Record<'withdraw()void' | 'withdraw', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      /**
       * Event begin timestamp
       */
      eventBegin?: IntegerState
      /**
       * Event end timestamp
       */
      eventEnd?: IntegerState
      /**
       * Event owner
       */
      eventOwner?: BinaryState
      eventStatus?: IntegerState
      lastTypeIndex?: IntegerState
      name?: BinaryState
      usdcAsset?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type EventManagerSig = keyof EventManager['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends EventManagerSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the EventManager smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends EventManagerSig> = EventManager['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the EventManager smart contract to the method's return type
 */
export type MethodReturn<TSignature extends EventManagerSig> = EventManager['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type EventManagerCreateCalls = (typeof EventManagerCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type EventManagerCreateCallParams =
  | (TypedCallParams<undefined> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type EventManagerDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: EventManagerCreateCalls) => EventManagerCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class EventManagerCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the EventManager smart contract using a bare call
       *
       * @param params Any parameters for the call
       * @returns A TypedCallParams object for the call
       */
      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: undefined,
          methodArgs: undefined,
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static startEvent(args: MethodArgs<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.name, args.owner, args.usdcAsset, args.beginTs, args.endTs, args.ttUrls, args.ttHash, args.ttPrices, args.ttSupply, args.ttMaxPerUser, args.ttSoldAmount, args.payMbr],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static buyTicket(args: MethodArgs<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.numberTickets, args.ticketTypeIndex, args.seats, args.payMbr, args.payAsset],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the claim_asset(account,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static claimAsset(args: MethodArgs<'claim_asset(account,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'claim_asset(account,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.assetId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the freeze_asset(account,uint64,byte[32])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static freezeAsset(args: MethodArgs<'freeze_asset(account,uint64,byte[32])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'freeze_asset(account,uint64,byte[32])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.assetId, args.seat],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the un_freeze_asset(account,uint64,byte[32])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static unFreezeAsset(args: MethodArgs<'un_freeze_asset(account,uint64,byte[32])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'un_freeze_asset(account,uint64,byte[32])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.assetId, args.seat],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the withdraw()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static withdraw(args: MethodArgs<'withdraw()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'withdraw()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
}

/**
 * A client to make calls to the EventManager smart contract
 */
export class EventManagerClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `EventManagerClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof EventManager['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the EventManager smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: EventManagerDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(EventManagerCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the EventManager smart contract using a bare call.
       *
       * @param args The arguments for the bare call
       * @returns The create result
       */
      async bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<undefined, AppCreateCallTransactionResult>(await $this.appClient.create(args))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the EventManager smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public startEvent(args: MethodArgs<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.startEvent(args, params))
  }

  /**
   * Calls the buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public buyTicket(args: MethodArgs<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.buyTicket(args, params))
  }

  /**
   * Calls the claim_asset(account,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public claimAsset(args: MethodArgs<'claim_asset(account,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.claimAsset(args, params))
  }

  /**
   * Calls the freeze_asset(account,uint64,byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public freezeAsset(args: MethodArgs<'freeze_asset(account,uint64,byte[32])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.freezeAsset(args, params))
  }

  /**
   * Calls the un_freeze_asset(account,uint64,byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public unFreezeAsset(args: MethodArgs<'un_freeze_asset(account,uint64,byte[32])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.unFreezeAsset(args, params))
  }

  /**
   * Calls the withdraw()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public withdraw(args: MethodArgs<'withdraw()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(EventManagerCallFactory.withdraw(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<EventManager['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get eventBegin() {
        return EventManagerClient.getIntegerState(state, 'event_begin')
      },
      get eventEnd() {
        return EventManagerClient.getIntegerState(state, 'event_end')
      },
      get eventOwner() {
        return EventManagerClient.getBinaryState(state, 'event_owner')
      },
      get eventStatus() {
        return EventManagerClient.getIntegerState(state, 'event_status')
      },
      get lastTypeIndex() {
        return EventManagerClient.getIntegerState(state, 'last_type_index')
      },
      get name() {
        return EventManagerClient.getBinaryState(state, 'name')
      },
      get usdcAsset() {
        return EventManagerClient.getIntegerState(state, 'usdc_asset')
      },
    }
  }

  public compose(): EventManagerComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      startEvent(args: MethodArgs<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.startEvent(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      buyTicket(args: MethodArgs<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.buyTicket(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      claimAsset(args: MethodArgs<'claim_asset(account,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.claimAsset(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      freezeAsset(args: MethodArgs<'freeze_asset(account,uint64,byte[32])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.freezeAsset(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      unFreezeAsset(args: MethodArgs<'un_freeze_asset(account,uint64,byte[32])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.unFreezeAsset(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      withdraw(args: MethodArgs<'withdraw()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.withdraw(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as EventManagerComposer
  }
}
export type EventManagerComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startEvent(args: MethodArgs<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'start_event(string,account,asset,uint64,uint64,string[],byte[32][],uint64[],uint64[],uint64[],uint64[],pay)void'>]>

  /**
   * Calls the buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  buyTicket(args: MethodArgs<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'buy_ticket(account,uint64,uint64,byte[32][],pay,axfer)void'>]>

  /**
   * Calls the claim_asset(account,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  claimAsset(args: MethodArgs<'claim_asset(account,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'claim_asset(account,uint64)void'>]>

  /**
   * Calls the freeze_asset(account,uint64,byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  freezeAsset(args: MethodArgs<'freeze_asset(account,uint64,byte[32])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'freeze_asset(account,uint64,byte[32])void'>]>

  /**
   * Calls the un_freeze_asset(account,uint64,byte[32])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unFreezeAsset(args: MethodArgs<'un_freeze_asset(account,uint64,byte[32])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'un_freeze_asset(account,uint64,byte[32])void'>]>

  /**
   * Calls the withdraw()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdraw(args: MethodArgs<'withdraw()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, MethodReturn<'withdraw()void'>]>

  /**
   * Makes a clear_state call to an existing instance of the EventManager smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): EventManagerComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): EventManagerComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<EventManagerComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<EventManagerComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type EventManagerComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type EventManagerComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
